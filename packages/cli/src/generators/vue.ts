import fs from "fs-extra";
import path from "path";
import { ProcessedIcon } from "@iconforge/core";

/**
 * Generate Vue components and types for icons
 */
export async function generateVue(icons: ProcessedIcon[], outputDir: string) {
  const vueDir = path.join(outputDir, "vue");
  await fs.ensureDir(vueDir);

  // 1. Generate types.ts
  const iconNames = icons.map((i) => i.name).sort();
  const typesContent = `export type IconName = 
${iconNames.map((name) => `  | '${name}'`).join("\n")};

export const iconNames: IconName[] = [
${iconNames.map((name) => `  '${name}',`).join("\n")}
];
`;
  await fs.writeFile(path.join(vueDir, "types.ts"), typesContent);

  // 2. Generate SvgSymbols.vue
  const symbolsContent = `<script setup lang="ts">
/**
 * SVG Symbols component - Generated by IconForge CLI
 * Include this component once at the root of your app (e.g., App.vue or layout)
 */
defineOptions({
  name: 'SvgSymbols',
});
</script>

<template>
  <svg
    style="position: absolute; width: 0; height: 0; overflow: hidden"
    xmlns="http://www.w3.org/2000/svg"
    aria-hidden="true"
  >
${icons
  .map((icon) => {
    const innerContent = icon.optimizedContent
      .replace(/<svg[^>]*>|<\/svg>/g, "")
      .trim();
    return `    <symbol id="${icon.name}" viewBox="${icon.viewBox}">
      ${innerContent}
    </symbol>`;
  })
  .join("\n")}
  </svg>
</template>
`;
  await fs.writeFile(path.join(vueDir, "SvgSymbols.vue"), symbolsContent);

  // 3. Generate Icon.vue (統一命名為 Icon)
  const iconComponentContent = `<script setup lang="ts">
import { computed, type CSSProperties } from 'vue';
import type { IconName } from './types';

/**
 * Icon component - Generated by IconForge CLI
 * Usage: <Icon name="icon_name" :size="24" color="#333" />
 */
export interface IconProps {
  /** Icon name (type-safe) */
  name: IconName;
  /** Size in px (applies to both width and height) */
  size?: number | string;
  /** Width (overrides size) */
  width?: number | string;
  /** Height (overrides size) */
  height?: number | string;
  /** Color (applies to currentColor) */
  color?: string;
  /** Accessible label (for screen readers) */
  ariaLabel?: string;
}

defineOptions({
  name: 'Icon',
  inheritAttrs: false,
});

const props = withDefaults(defineProps<IconProps>(), {
  size: 24,
});

const iconId = computed(() => \`#\${props.name}\`);
const iconWidth = computed(() => props.width ?? props.size);
const iconHeight = computed(() => props.height ?? props.size);

const iconStyle = computed<CSSProperties>(() => ({
  display: 'inline-block',
  flexShrink: 0,
  color: props.color,
}));

const ariaHidden = computed(() => !props.ariaLabel);
</script>

<template>
  <svg
    :width="iconWidth"
    :height="iconHeight"
    :style="iconStyle"
    :aria-hidden="ariaHidden"
    :aria-label="ariaLabel"
    :role="ariaLabel ? 'img' : undefined"
    focusable="false"
    v-bind="$attrs"
  >
    <use :href="iconId" />
  </svg>
</template>
`;
  await fs.writeFile(path.join(vueDir, "Icon.vue"), iconComponentContent);

  // 4. Generate useIcon.ts with registry
  const useIconContent = `import { computed, ref, type ComputedRef, type Ref } from 'vue';
import type { IconName } from './types';

/**
 * Icon metadata
 */
export interface IconMetadata {
  id: IconName;
  viewBox: string;
  content: string;
}

/**
 * Icon registry type
 */
export type IconRegistry = Record<IconName, IconMetadata>;

/**
 * Internal registry - populated by iconRegistry below
 */
const internalRegistry: Ref<IconRegistry> = ref({} as IconRegistry);

/**
 * Icon registry with all icon metadata
 */
export const iconRegistry: IconRegistry = {
${icons
  .map((icon) => {
    const innerContent = icon.optimizedContent
      .replace(/<svg[^>]*>|<\/svg>/g, "")
      .trim()
      .replace(/'/g, "\\'")
      .replace(/\n/g, "\\n");
    return `  '${icon.name}': {
    id: '${icon.name}',
    viewBox: '${icon.viewBox}',
    content: '${innerContent}',
  },`;
  })
  .join("\n")}
};

// Initialize internal registry
internalRegistry.value = iconRegistry;

/**
 * useIcon composable - get icon metadata reactively
 * @param name - Icon name
 * @returns Icon metadata or null
 *
 * @example
 * \`\`\`vue
 * <script setup>
 * import { useIcon } from './useIcon';
 * const homeIcon = useIcon('home');
 * </script>
 *
 * <template>
 *   <svg v-if="homeIcon" :viewBox="homeIcon.viewBox">
 *     <use :href="\`#\${homeIcon.id}\`" />
 *   </svg>
 * </template>
 * \`\`\`
 */
export function useIcon(name: IconName): ComputedRef<IconMetadata | null> {
  return computed(() => internalRegistry.value[name] ?? null);
}

/**
 * Get all available icon names
 */
export function getIconNames(): ComputedRef<IconName[]> {
  return computed(() => Object.keys(internalRegistry.value) as IconName[]);
}

/**
 * Check if an icon exists
 */
export function hasIcon(name: string): ComputedRef<boolean> {
  return computed(() => name in internalRegistry.value);
}
`;
  await fs.writeFile(path.join(vueDir, "useIcon.ts"), useIconContent);

  // 5. Generate index.ts
  const indexContent = `// Types
export type { IconName } from './types';
export { iconNames } from './types';

// Components
export { default as Icon } from './Icon.vue';
export { default as SvgSymbols } from './SvgSymbols.vue';

// Composables
export {
  useIcon,
  getIconNames,
  hasIcon,
  iconRegistry,
  type IconMetadata,
  type IconRegistry,
} from './useIcon';

// Re-export component props types
export type { IconProps } from './Icon.vue';
`;
  await fs.writeFile(path.join(vueDir, "index.ts"), indexContent);
}
